---
title: "Constructing Diversification Measures (eg, MS = 1 if a multiple-segment firm)"
output:
  html_notebook: default
  # html_document: default
  # word_document: default
---


# Load raw data and required library
```{r}

name_df = "segmentHist"

mainDir = Sys.getenv("Data") #'D:/github/Data/'
subDir = '/Segment/'
dir.create(file.path(mainDir, subDir), showWarnings = FALSE, recursive = TRUE)


###################################################################################
time_stamp = "2019-10-31_23.55.19"
data_cleaned <- readRDS(paste0(mainDir, subDir, name_df, "_clean", time_stamp, '.rds')) 
###################################################################################


library(tidyverse)
library(magrittr)
library(lubridate)
library(stargazer)



#=====================================================
# Variable list for this dataset
vars = "datadate, srcdate, srcs, upds, gvkey, sics1, sics2, sics3, 
stype, sid, snms, soptp1, soptp2, geotp, naicsh, naicss1, naicss2, naicss3,

emps, emps_dc, emps_fn, obs, obs_dc, 
intseg, intseg_dc, oelim, oelim_dc, 
esubs, esubs_dc, esubs_fn, ivaeqs, ivaeqs_dc, 
salexg, salexg_dc, spis, spis_dc, xidos, xidos_dc, 

atlls, atlls_dc, capxs, capxs_dc, capxs_fn, caxts, caxts_dc, 
cogss, cogss_dc, dps, dps_dc, gdwls, gdwls_dc, 

ias, ias_dc, ibs, ibs_dc, iints, iints_dc, 
nis, nis_dc, nopxs, nopxs_dc, nxints, nxints_dc, ocaxs, ocaxs_dc, 
oiadps, oiadps_dc, oibdps, oibdps_dc, ops, ops_dc, ops_fn, 
ppents, ppents_dc, ptis, ptis_dc, rds, rds_dc, rds_fn, 

revts, revts_dc, sales, sales_dc, sales_fn,  
txts, txts_dc, txws, txws_dc, 
xints, xints_dc, xsgas, xsgas_dc, 

curcds, 
isosrc 
"  

```


## Remarks on filtering criteria by Custodio (2014)---------------------------------------------------------------

sample of firms in Compustat Segments data from [1988 to 2007] meeting the following criteria:

* firms with missing segment SIC codes are excluded

* firms must *NOT* have any [*business* segment] in the 
  - financial sector (SIC codes 6000 to 6999), 
  - agriculture (SIC code lower than 1000), 
  - government (SIC 9000), or 
  - other noneconomic activities (SIC 8600 and 8800); 

##----------------------------------------------------------------------------------------------------------------

# Compute number of segments, other diversification measures, and sums of sales|ias (Custodio 2014)
```{r}

segmData <- data_cleaned %>% # 296944
  # remove gvkey-datadate obs with unwanted segment SIC's by first setting unwanted sics_my to NA
  mutate(sics_my = ifelse((sics_my >= 6000 & sics_my <= 6999) 
                          | (sics_my >= 0000 & sics_my <= 1000)
                          | sics_my == 9000
                          | sics_my == 8600 | sics_my == 8800 #| sics_my == 8900
                          , NA, sics_my)) %>%   # need to set to NA in order to use anyNA() later
  mutate(rm_flag = FALSE) %>% # set initial value of rm_flag (ie, by default, do not remove)
  group_by(
    stype,   
    gvkey, datadate) %>% 
########################################################## <----------------------------------------- !!! 
# Custodio said to have removed all obs with any missing-value sics1 or unwanted sics_my
  mutate(rm_flag = ifelse(sum(is.na(sics1)|is.na(sics_my)) > 0, TRUE, FALSE)) %>% 
##########################################################  
  ungroup() %>% 
  filter(!rm_flag) %>% 
  select(gvkey, stype, datadate, fyears, sid, sics_my, sics1, sics2, sics3, snms,
         everything()) %>% 

  #=======================================================
  # compute nseg = number of segments, MS = 1 if nseg > 1L
  group_by(
    stype,   
    gvkey, datadate) %>% 
  mutate(nseg = n(),
         saleSUM = sum(sales),
         iaSUM = sum(ias),
         w_sales = sales/saleSUM,
         w_ias = ias/iaSUM,
         ) %>% 
  ungroup() %>% 
  # define dummy for multiple-segment firms
  mutate(MS = as.integer(nseg > 1)) %>% 
  arrange(desc(nseg), gvkey, stype, datadate, sid) %>% 
  select(gvkey, stype, soptp1, geotp, isosrc, datadate, fyears, MS, nseg, 
         saleSUM, iaSUM, 
         rm_flag, sid, sics_my, sics1, sics2, snms, 
         everything()) %>% 
  select(everything())

```


## More remarks on filtering criteria by Custodio (2014)---------------------------------------------------------------

sample of firms in Compustat Segments data from [1988 to 2007] meeting the following criteria:

* firms for unclassified services (SIC 8900) are excluded; 
  
* firm sales greater than $20 million; 

* firms for which the [sum of business segment sales or assets] deviates from the [firmâ€™s total sales or assets] by [more than 5%]
are also excluded, 

##----------------------------------------------------------------------------------------------------------------

# Read in Compustat Fundamental [Annual] Data (_raw) and define variables
```{r}

# The raw Fundamental Annual is most complete as it's not subject to prior deficiency in handling data
dDiscA <- readRDS(paste0(Sys.getenv("Data"), "/Compustat/", "inferEarnA_raw", "2019-11-04_01.36.36", '.rds')) %>% 
  # (note: must remove is.na(fyear) first, or NA with be matched to is.na(fyearq))
  filter(!is.na(fyear)) %>%  
  # apply Custodio's criterion: sale >= 20 million
  filter(sale > 20) %>%  
  # The next is implicitly required to implement the "no larger than 5% deviation" criteria
  # because at is to be used as the base and hence has to be positive
  filter(at > 0) %>% 
#########################################  
  # apply Custodio's criterion:
  filter(sich != 8900) %>%   
#########################################
  # Define different levels of SIC to facilitate imputed value computation later
  mutate(
    SIC4 = ((sich/10000) + 0.00001) %>% substr(3,6) %>% as.character(),
    SIC3 = SIC4 %>% substr(1,3), 
    SIC2 = SIC4 %>% substr(1,2),
    SIC1 = SIC4 %>% substr(1,1),
    ) %>% 
  #==============================================
  #keep a record of the original measures
  mutate_at(vars(gdwl, capx), list(orig = ~ (.))) %>%  
  # Unconditionally replace NA with zero because in this case, omission of reported items is likely due to zero value
  mutate_at(vars(gdwl, capx), ~ ifelse(is.na(.x), 0, .x)) %>%   
  #==============================================
  mutate(
    at_MV = at - ceq + prcc_f*csho,
    atAdj = at - gdwl,  # Is gdwl >= 0 ?
    atAdj_MV = atAdj - ceq + prcc_f*csho,
    atAdj_MV = ifelse(atAdj_MV < 0, NA, atAdj_MV), # remove negative atAdj_MV, which would give meaningless xvAdj

    q_Obs = at_MV/at,
    qAdj_Obs = atAdj_MV/atAdj,

    log_at = log(at),
    log_atAdj = log(atAdj),
    ebit2sale = oiadp/sale,
    capx2sale = capx/sale, 
    ) %>% 
  select(everything()) 


```


# Merge Fundamental Annual data to Segment data (segment-centric)
  !!! Note: one annual fyear can be merged to same segment fyears with different datadate's in the same fiscal year)
```{r}

# Custodio's sample period for segment data
startdate = "1988-01-01"
enddate = "2007-12-31"


dDiscSegA <- segmData %>% 
  # differentiate segment datadate from annual datadate by renaming
  rename(datadates = datadate) %>% 
  inner_join(dDiscA, by = c("gvkey", "fyears" = "fyear")) %>% 
  # ensure the annual data merged in is not latter than the segment datadates
  filter(datadate <= datadates) %>%  
  # apply Custodio's criterion: deviation in sale|at <= 5%
  filter(abs(1 - saleSUM/sale) <= 0.05) %>%  
  filter(abs(1 - iaSUM/at) <= 0.05) %>%  
  # Custodio's sample period
  filter(datadates >= startdate & datadates <= enddate) %>%  
#################################################################
  # Define new variables for regression later
#################################################################
  select(sale, saleSUM, at, iaSUM, everything())


# convert to annual-centric dDiscAnnS from the segment-centric dDiscSegA
dDiscAnnS <- dDiscSegA %>% 
  # keep only rows with distinct gvkey-datadates pairs
  distinct(gvkey, datadates, .keep_all = TRUE)  
 

# summary of key features
dDiscAnnS %>% 
  mutate_at(vars(nseg, MS), ~ as.factor(.)) %>% 
  select(nseg, MS, fyears, sale, saleSUM, at, iaSUM,
         gdwl, at_MV:capx2sale,
         ) %>% 
  summary()

```


# Construct segment q_Imp as the median q of the narrowest SIC industry with 5 or more single-segment firms
```{r}
# map each 4-digit SIC to the industry-median q of the narrowest SIC industry with 5 or more single-segment firms
nObs_min = 5
qqAdj_IndSS <- dDiscAnnS %>% 
  filter(MS == 0) %>%  # keep only SS firms
  filter(!is.na(q_Obs)) %>% # keep only those with non-missing q_Obs
  group_by(SIC4, fyears) %>%  
  mutate(n4 = n(), 
         q_Ind = ifelse(n4 < nObs_min, NA, median(q_Obs)),
         qAdj_Ind = ifelse(n4 < nObs_min, NA, median(qAdj_Obs)),
         ) %>% 
  group_by(SIC3, fyears) %>%  
  mutate(n3 = n(), 
         q_Ind = ifelse(n3 < nObs_min, NA, ifelse(is.na(q_Ind), median(q_Obs), q_Ind)),
         qAdj_Ind = ifelse(n3 < nObs_min, NA, ifelse(is.na(qAdj_Ind), median(qAdj_Obs), qAdj_Ind)),
         ) %>% 
  group_by(SIC2, fyears) %>%  
  mutate(n2 = n(), 
         q_Ind = ifelse(n2 < nObs_min, NA, ifelse(is.na(q_Ind), median(q_Obs), q_Ind)),
         qAdj_Ind = ifelse(n2 < nObs_min, NA, ifelse(is.na(qAdj_Ind), median(qAdj_Obs), qAdj_Ind)),
         ) %>% 
  group_by(SIC1, fyears) %>%  
  mutate(n1 = n(), 
         q_Ind = ifelse(n1 < nObs_min, NA, ifelse(is.na(q_Ind), median(q_Obs), q_Ind)),
         qAdj_Ind = ifelse(n1 < nObs_min, NA, ifelse(is.na(qAdj_Ind), median(qAdj_Obs), qAdj_Ind)),
         ) %>% 
  ungroup() %>% 
  distinct(sich, fyears, q_Ind, qAdj_Ind)

```


# Construct imputed q and excess value variables
```{r}
dDiscSegAxv <- dDiscSegA %>% 
  left_join(qqAdj_IndSS, by = c("sics1" = "sich", "fyears")) %>% 
  select(q_Ind, qAdj_Ind, everything()) %>% 
  mutate(q_Imp_sw = w_sales*q_Ind,   
         q_Imp_aw = w_ias*q_Ind,
         qAdj_Imp_sw = w_sales*qAdj_Ind,   
         qAdj_Imp_aw = w_ias*qAdj_Ind,
         ) %>% 
  group_by(gvkey, fyears) %>% 
  mutate(q_Imp_sw = sum(q_Imp_sw),
         q_Imp_aw = sum(q_Imp_aw),
         qAdj_Imp_sw = sum(qAdj_Imp_sw),
         qAdj_Imp_aw = sum(qAdj_Imp_aw),
         ) %>% 
  ungroup() %>% 
  mutate(
    xv_sw = log(q_Obs/q_Imp_sw),
    xv_aw = log(q_Obs/q_Imp_aw),
    xvAdj_sw = log(qAdj_Obs/qAdj_Imp_sw),
    xvAdj_aw = log(qAdj_Obs/qAdj_Imp_aw),
    ) %>%
  select(matches("^q(|Adj)_Imp_"), matches("^xv(|Adj)_"), everything())


# convert to annual-centric dDiscAnnSxv from the segment-centric dDiscSegAxv
dDiscAnnSxv <- dDiscSegAxv %>% 
  # define factor variable fyears_fac (when included in regression, it works like year dummy variables) 
  mutate(#gvkey_fac = as.factor(gvkey),
         fyears_fac = as.factor(fyears)
         ) %>% 
  # keep only rows with distinct gvkey-datadates pairs
  distinct(gvkey, datadates, .keep_all = TRUE) %>% # only 66297; 65709 if using Compustat fyear convention
  arrange(gvkey, fyears, datadates)


                                                # #install.packages("rlang")
                                            # library(rlang)
                                            # library(inspectdf)
                                            # library(skimr)
                                                # #devtools::install_github("ropensci/skimr")


```


# excess value regressions (unadjusted and goodwill-adjusted)
```{r}


fm.regr <- "xv ~ MS + lat + ebit2sale + capx2sale" %>% as.formula()

mod_aw <- lm(xv ~ MS + lat + ebit2sale + capx2sale + fyears_fac, 
             dat = (dDiscAnnSxv %>% mutate(xv = xv_aw, lat = log_at))
             ) 

modAdj_aw <- lm(xv ~ MS + lat + ebit2sale + capx2sale + fyears_fac, 
                dat = (dDiscAnnSxv %>% mutate(xv = xvAdj_aw, lat = log_atAdj))
                )

mod_sw <- lm(xv ~ MS + lat + ebit2sale + capx2sale + fyears_fac, 
             dat = (dDiscAnnSxv %>% mutate(xv = xv_sw, lat = log_at))
             ) 

modAdj_sw <- lm(xv ~ MS + lat + ebit2sale + capx2sale + fyears_fac, 
                dat = (dDiscAnnSxv %>% mutate(xv = xvAdj_sw, lat = log_atAdj))
                ) 


# Display regression results in table
suppressWarnings(
stargazer::stargazer(mod_aw, modAdj_aw, mod_sw, modAdj_sw, 
                     dep.var.labels.include = FALSE, 
                     column.labels = c('xv\\_aw', 'xvAdj\\_aw', "xv\\_sw", "xvAdj\\_sw"), 
                     omit = c("_fac"),  
                     type = "text")
)


```




